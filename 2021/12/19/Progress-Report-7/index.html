<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Li Wenjian">







<title>Progress Report 7 | keep alive</title>



    <link rel="icon" href="/logo.png">



<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=Roboto+Mono&display=swap');
</style>



    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    




    <!-- scripts list from _config.yml -->
    
    <script src="/js/frame.js"></script>
    




    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>



<script src='https://unpkg.com/valine@1.4.16/dist/Valine.min.js'></script>

<script type="text/javascript" src="/js/jquery-1.8.3.min.js"></script>
<script src="/js/jquery.jscroll.js"></script>
<style type="text/css">
  pre { margin: 0; }
  .centered { width: 380px; margin: 0 auto 0 auto; font-size: 10px; line-height: 10px;}
  h1 { text-align: center; }
</style>
<script type="text/javascript">
  $(function () {
    $('#horse').jscroll({
      padding: 2000,
      loadingHtml: ''
    });
  });
</script>

  <!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.1"><link rel="alternate" href="/atom.xml" title="keep alive" type="application/atom+xml">
</head>
  <body>
    <div class="mask-border">
    </div>

    <div class="wrapper">

      <div class="header">
  <div class="flex-container">
    <div class="header-inner">
      <div class="site-brand-container">
        <a href="/">
          
            <img class="logo-img" src="/cnaidc.png" alt="logo_image">
            
        </a>
      </div>
      <div id="menu-btn" class="menu-btn" onclick="toggleMenu()">
        Menu
      </div>
      <nav class="site-nav">
        <ul class="menu-list">
          
            
              <li class="menu-item">
                <a href="/">Home</a>
              </li>
            
          
            
              <li class="menu-item">
                <a href="/archives/">Archive</a>
              </li>
            
          
            
              <li class="menu-item">
                <a href="/categories/gallery/">Gallery</a>
              </li>
            
          
            
              <li class="menu-item">
                <a href="/about">About</a>
              </li>
            
          
        </ul>
      </nav>
    </div>
  </div>
</div>


      <div class="main">
        <div class="flex-container">
          <article id="post">

  
    <div class="post-head">
    <div class="post-info">
        <div class="tag-list">
            
                
                    <span class="post-tag">
                        <a href="/tags/Notes/">
                            Notes
                        </a>
                    </span>    
                
                    <span class="post-tag">
                        <a href="/tags/SLAM/">
                            SLAM
                        </a>
                    </span>    
                
                    <span class="post-tag">
                        <a href="/tags/graduation-project/">
                            graduation project
                        </a>
                    </span>    
                
                    <span class="post-tag">
                        <a href="/tags/%E8%A7%86%E8%A7%89SLAM%E5%8D%81%E5%9B%9B%E8%AE%B2/">
                            视觉SLAM十四讲
                        </a>
                    </span>    
                           
            
        </div>
        <div class="post-title">
            
            
                Progress Report 7
            
            
        </div>
        <span class="post-date">
            2021, 12, 19
        </span>
    </div>
    <div class="post-img">
        
            <div class="h-line-primary"></div>
              
    </div>
</div>
    <div class="post-content">
    <h2><span id="进展">进展</span></h2>
<blockquote>
<p>第十五周主要完成了对《视觉SLAM十四讲》中第九讲——后端1的学习。内容包括以EKF为代表的滤波器后端和非线性优化后端。</p>
</blockquote>
<p>这一章的理论非常多，并且书上讲的并不透彻。所以又去看了很多相关的资料，比如说<a target="_blank" rel="noopener" href="https://www.youtube.com/channel/UCi1TC2fLRvgBQNe-T4dp8Eg">Cyrill Stachniss</a>发布的课程<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=LhWUwzYcZuw&amp;t=1221s">Photogrammetry II - 07c - Bundle Adjustment - Part 2 (2015/16) - YouTube</a>, <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=Tz3pg3d1TIo">SLAM Course - 12 - FastSLAM (2013/14; Cyrill Stachniss) - YouTube</a>等等。</p>
<h3><span id="后端概述">后端概述</span></h3>
<p>我的理解是，**前端只利用两帧图像进行定位与建图，而后端利用多张图像进行定位与建图。**这样做的好处有：</p>
<ul>
<li><strong>更完整的地图</strong>：比如说我们要建图的对象很复杂，仅仅使用两个图像可能依然会有一些遮挡的情况。必须从更对的位置对它进行观察才能获得其完整的样貌。</li>
<li><strong>更完整的路径</strong>：显然，如果想知道相机每一帧的位姿，也就是完整的路径，对每一帧都要进行估计。</li>
<li><strong>更高精度</strong>：单纯的使用前端会产生<strong>累计误差</strong>，意思是每使用一次视觉里程计，它都会有一定的不确定性，而一味的往前走这个不确定性就会累计。如果对每一步的估计都向右偏了1°，累积起来后果依然会很大。但是其实后面的观测对前面的观测依然有降低其不确定性的作用。所以说，考虑全局最优就是在消除累计误差。</li>
</ul>
<h3><span id="滤波器后端">滤波器后端</span></h3>
<p>滤波器是过去SLAM后端的主流方法（尤其是LiDAR里）。这种方法主要是从概率论的角度来看状态估计，在SLAM里要估计的状态就是相机的位姿$\boldsymbol x_1$到$\boldsymbol x_N$和路标的位置$\boldsymbol y_1$到$\boldsymbol y_M$了。</p>
<p>SLAM过程可以由运动方程和观测方程描述：<br>
$$<br>
\begin{array}{c}<br>
\boldsymbol x_k = f(\boldsymbol x_{k-1}, \boldsymbol u_k)+\boldsymbol w_k \<br>
\boldsymbol z_k = h(\boldsymbol y_j, \boldsymbol x_k)+\boldsymbol v_{k,j}<br>
\end{array}<br>
\ \ \ \ \ \ \ k = 1,…,N,j=1,…,M<br>
$$<br>
由于误差项的存在，这里的位姿和路标位置并不是确定的量，而是一些<strong>随机变量</strong>。</p>
<blockquote>
<p>举个例子，假如说运动方程中的$\boldsymbol u_k$是向正北走了1m，也就是机器人执行了向正北走1m的指令。但可能由于路面并不平，或者左边的轮子比右边的轮子大几毫米，或者就是单纯的多/少走了2cm，等等因素，真正的运动并不是真的向正北走1m。</p>
</blockquote>
<p>在这样的想法下，SLAM问题就变成了**“什么样的位姿和路标状态最有可能产生现在的观测？”<strong>的问题，也就是一种</strong>极大似然估计**。</p>
<p>记$k$时刻所有待估计的未知量为$\boldsymbol x_k\stackrel{\mathrm{def}}{=}{\boldsymbol x_k,\boldsymbol y_1,…,\boldsymbol y_M}$，运动和观测方程就变成了<br>
$$<br>
\left{<br>
\begin{array}{c}<br>
\boldsymbol x_k = f(\boldsymbol x_{k-1}, \boldsymbol u_k)+\boldsymbol w_k \<br>
\boldsymbol z_k = h( \boldsymbol x_k)+\boldsymbol v_{k,j}<br>
\end{array}<br>
\ \ \ \ \ \ \ k = 1,…,N<br>
\right.<br>
$$<br>
以下为贝叶斯滤波器的推导，我觉得书上并没有讲清楚，就补充在这里了</p>
<blockquote>
<p>我们希望通过$0$到$k$时刻得到的数据（运动的指令$\boldsymbol u_{1:k}$以及观测$\boldsymbol z_{1:k}$）求解$\boldsymbol x_k$的分布情况，在滤波器里也就是要找到下面式子的<strong>递推公式</strong>（可能是因为SLAM强调时序性）<br>
$$<br>
P(\boldsymbol x_k|\boldsymbol x_0, \boldsymbol u_{1:k}, \boldsymbol z_{1:k})<br>
$$<br>
按照贝叶斯公式，交换$\boldsymbol z_{k}$和$\boldsymbol x_{k}$可以得到<br>
$$<br>
P(\boldsymbol x_k|\boldsymbol x_0, \boldsymbol u_{1:k}, \boldsymbol z_{1:k})= \eta \underline {P(\boldsymbol z_{k}|\boldsymbol x_{k}, \boldsymbol u_{1:k}, \boldsymbol z_{1:k-1})}P(\boldsymbol x_k|\boldsymbol x_0, \boldsymbol u_{1:k}, \boldsymbol z_{1:k-1})<br>
$$<br>
其中$\eta$为归一化因子。第二项是观测$\boldsymbol z_{k}$的分布，这显然只与当前的位姿和路标有关，和之前的观测/运动都无关，所以也可以写成<br>
$$<br>
P(\boldsymbol x_k|\boldsymbol x_0, \boldsymbol u_{1:k}, \boldsymbol z_{1:k})= \eta P(\boldsymbol z_{k}|\boldsymbol x_{k})\underline {P(\boldsymbol x_k|\boldsymbol x_0, \boldsymbol u_{1:k}, \boldsymbol z_{1:k-1})}<br>
$$<br>
按照全概率公式以$\boldsymbol x_{k-1}$为条件展开可得<br>
$$<br>
P(\boldsymbol x_k|\boldsymbol x_0, \boldsymbol u_{1:k}, \boldsymbol z_{1:k-1})=\int_{\boldsymbol x_{k-1}}\underline{P(\boldsymbol x_k|\boldsymbol x_{k-1},\boldsymbol x_0, \boldsymbol u_{1:k}, \boldsymbol z_{1:k-1})}P(\boldsymbol x_{k-1}|\boldsymbol x_0, \boldsymbol u_{1:k}, \boldsymbol z_{1:k-1})dx_{k-1}<br>
$$<br>
假设马尔可夫性，$\boldsymbol x_k$只与$k-1$有关，与$k-1$之前都无关，就有<br>
$$<br>
P(\boldsymbol x_k|\boldsymbol x_0, \boldsymbol u_{1:k}, \boldsymbol z_{1:k})= \eta P(\boldsymbol z_{k}|\boldsymbol x_{k})\int <em>{\boldsymbol x</em>{k-1}}P(\boldsymbol x_k|\boldsymbol x_{k-1}, \boldsymbol u_{k})P(\boldsymbol x_{k-1}|\boldsymbol x_0, \underline{\boldsymbol u_{1:k}}, \boldsymbol z_{1:k-1})dx_{k-1}<br>
$$<br>
再假设$\boldsymbol x_{k-1}$与$\boldsymbol u_k$无关，就有</p>
<p>但其实也不一定无关，假如，世界只有前后间隔1m的两个可能的位置，$k$时刻的运动是<strong>向前1m</strong>，那么$k-1$的位置只可能是在<strong>后面</strong>而不是前面</p>
<p>$$<br>
P(\boldsymbol x_k|\boldsymbol x_0, \boldsymbol u_{1:k}, \boldsymbol z_{1:k})= \eta P(\boldsymbol z_{k}|\boldsymbol x_{k})\int <em>{\boldsymbol x</em>{k-1}}P(\boldsymbol x_k|\boldsymbol x_{k-1}, \boldsymbol u_{k})\underline{P(\boldsymbol x_{k-1}|\boldsymbol x_0, \boldsymbol u_{1:k-1}, \boldsymbol z_{1:k-1})}dx_{k-1}<br>
$$<br>
而这里$P(\boldsymbol x_{k-1}|\boldsymbol x_0, \boldsymbol u_{1:k-1}, \boldsymbol z_{1:k-1})$就是$k-1$时刻的分布。这样我们就有了求解$\boldsymbol x_k$的分布情况的递归方法，以上也被称为<strong>贝叶斯滤波器</strong>。</p>
</blockquote>
<p>但实际上贝叶斯滤波器只是一个框架，并没有给出这个求积分的方法。具体的方法可以分为<strong>卡尔曼滤波器</strong>和<strong>粒子滤波器</strong>两大类。</p>
<ul>
<li>运动和观测方程均线性，噪声满足高斯分布→<strong>卡尔曼滤波器</strong></li>
<li>运动和观测方程非线性，但在某个点附近泰勒展开，噪声满足高斯分布→<strong>扩展卡尔曼滤波器</strong></li>
<li>噪声不满足高斯分布，用粒子模拟分布情况→<strong>粒子滤波器</strong></li>
</ul>
<p>但是在滤波器中，由于做了马尔可夫性的假设，依然没有考虑当前状态和很久以前状态的关系。并且还有EKF的线性化只能在很小的范围内成立，协方差矩阵会很大，没有异常检测机制等问题。尤其是在视觉SLAM中特征点很多且很容易存在误差。现在通常认为在同等计算量的条件下，非线性优化能取得更好的结果。</p>
<h3><span id="非线性优化后端">非线性优化后端</span></h3>
<p>使用图优化求解BA。BA即Bundle Adjustment，意思是调整（adjustment）相机位姿和空间点的位置，使得从特征点发出的几束光线（bundles of light rays）对准相机的光心。这一张中讨论的BA很类似于SfM问题，也就是并没有考虑图像的时序性和计算的实时性。这一部分内容将在下一章滑动窗口优化中讲解。</p>
<h4><span id="投影模型">投影模型</span></h4>
<p>投影模型如下<br>
$$<br>
\boldsymbol y=p=\begin{bmatrix}X\Y\Z\end{bmatrix}\xrightarrow[\text{相机坐标系}]{P’=Rp+t}<br>
\begin{bmatrix}X’\Y’\Z’\end{bmatrix}\xrightarrow[\text{归一化坐标}]{}<br>
\begin{bmatrix}X’/Z’\Y’/Z’\1\end{bmatrix}=\begin{bmatrix}u_c\v_c\1\end{bmatrix}\<br>
$$<br>
$$<br>
\xrightarrow[\text{畸变模型}]{k_1,k_2}<br>
\begin{bmatrix}u_c(1+k_1r_c^2+k_2r_c^4)\v_c(1+k_1r_c^2+k_2r_c^4)\end{bmatrix}=\begin{bmatrix}u_c’\v_c’\end{bmatrix}\xrightarrow[\text{相机模型}]{f_x, f_y, c_x, c_y}<br>
\begin{bmatrix}f_xu_c’+c_x\f_yv_c’+c_y\end{bmatrix}=\begin{bmatrix}u_s\v_s\end{bmatrix}=\boldsymbol z<br>
$$<br>
这个过程也就是之前讲的<strong>观测方程</strong><br>
$$<br>
\boldsymbol z=h(\boldsymbol x, \boldsymbol y)<br>
$$<br>
这里的$\boldsymbol x$就是相机的位姿，具体可以表示为李群$\boldsymbol T$或者李代数$\boldsymbol \xi$。那么，相机$\boldsymbol \xi_i$观测到特征点$\boldsymbol p_j$的误差$\boldsymbol e_{ij}$就可以表示为<br>
$$<br>
\boldsymbol e_{ij}=\boldsymbol z_{ij}-h(\boldsymbol \xi_i, \boldsymbol p_j)<br>
$$<br>
<strong>注意这里的$\boldsymbol e_{ij}$并不是一个数值，而是二维向量</strong></p>
<p>整体的代价函数为<br>
$$<br>
\frac 1 2 \sum_{i=1}^m\sum_{j=1}^n \boldsymbol ||\boldsymbol e_{ij}||^2<br>
$$</p>
<blockquote>
<p>这个代价函数，看起来是个数值。但看了后面的我感觉把要优化的目标函数<strong>想成</strong>一个$2m×n$的矩阵比较合理。也就是类似这个样子<br>
$$<br>
\begin{bmatrix}e_{11_1} &amp;&amp; e_{12_1} &amp;&amp; …\<br>
e_{11_2} &amp;&amp; e_{12_2} &amp;&amp; …\<br>
e_{21_1} &amp;&amp; e_{22_1} &amp;&amp; …\<br>
e_{21_2} &amp;&amp; e_{22_2} &amp;&amp; …\<br>
… &amp;&amp; … &amp;&amp; …\end{bmatrix}<br>
$$<br>
或者这样的分块矩阵</p>
<p>$$<br>
\begin{bmatrix}\boldsymbol e_{11} &amp;&amp; \boldsymbol e_{12} &amp;&amp; …\<br>
\boldsymbol e_{21} &amp;&amp; \boldsymbol e_{22} &amp;&amp; …\<br>
… &amp;&amp; … &amp;&amp; …\end{bmatrix}<br>
$$<br>
但是后面好像还会重新排列一下，<strong>写出来</strong>可能更像是这样<br>
$$<br>
\begin{bmatrix}\boldsymbol e_{11}&amp;\boldsymbol e_{12}&amp;…&amp;\boldsymbol e_{21}&amp;\boldsymbol e_{22}&amp;…\end{bmatrix}^T<br>
$$<br>
总而言之，这里的矩阵到底是几乘几的好像并不重要，理解清楚$\boldsymbol e_{ij}$就行</p>
</blockquote>
<h4><span id="ba的求解">BA的求解</span></h4>
<p>求解BA的过程其实是不断通过$\boldsymbol H\Delta\boldsymbol x=\boldsymbol g$（高斯牛顿法）求解$\Delta\boldsymbol x$。而在后端中，这里的$\boldsymbol x$包含了所有的相机位姿和路标点位置<br>
$$<br>
\boldsymbol x=[\boldsymbol \xi_1,…,\boldsymbol \xi_m,\boldsymbol p_1,…,\boldsymbol p_n]^T\<br>
\boldsymbol x=[\boldsymbol x_c, \boldsymbol x_p]^T<br>
$$<br>
而雅可比矩阵也相应的分块为<br>
$$<br>
\boldsymbol J=\begin{bmatrix}\boldsymbol F\ \ \boldsymbol E\end{bmatrix}<br>
$$<br>
对应的$\boldsymbol H$矩阵为<br>
$$<br>
\boldsymbol H = \boldsymbol J^T\boldsymbol J=<br>
\begin{bmatrix}\boldsymbol F^T\boldsymbol F &amp; \boldsymbol F^T\boldsymbol E\\boldsymbol E^T\boldsymbol F &amp; \boldsymbol E^T\boldsymbol E\end{bmatrix}<br>
$$<br>
要求解$\boldsymbol H\Delta\boldsymbol x=\boldsymbol g$就要对$\boldsymbol H$求逆，矩阵求逆是一个$O(n^3)$复杂的的操作。对于<strong>特征点数量上百个</strong>的视觉SLAM，这种方法之所以可行是因为$\boldsymbol H$的特殊结构，而这种特殊结构正与图优化的图模型对应。</p>
<h4><span id="稀疏性和边缘化">稀疏性和边缘化</span></h4>
<p>$\boldsymbol H$的特殊结构就在于它并不是一个稠密的矩阵，尤其是在特征点对应的雅可比分块中。</p>
<blockquote>
<p>其实在滤波器（例如FastSLAM）中也会利用这一点，由于空间点（作为随机变量）的分布与其他特征点的位置是无关的，所以在估计的时候并不会使用很大的EKF，而是对每个空间点单独使用一个EKF进行估计。</p>
</blockquote>
<p>考虑代价函数的其中一个$\boldsymbol e_{ij}$<br>
$$<br>
\boldsymbol J_{ij}(x)=(\boldsymbol 0_{2×6},…,\boldsymbol 0_{2×6},\frac {\boldsymbol e_{ij}} {\boldsymbol \xi_{i}},\boldsymbol 0_{2×6},…\boldsymbol 0_{2×3},…,\boldsymbol 0_{2×3},\frac {\boldsymbol e_{ij}} {\boldsymbol p_{j}},\boldsymbol 0_{2×3},…,\boldsymbol 0_{2×3})<br>
$$<br>
显然相机在$\boldsymbol \xi_{i}$观测$\boldsymbol p_{j}$产生的误差只与$\boldsymbol \xi_{i}$和$\boldsymbol p_{j}$有关，所以雅可比矩阵有很强的稀疏性。从而导致$\boldsymbol H$也有很强的稀疏性</p>
<p><img src="https://s2.loli.net/2021/12/19/yWLJ2tKg1m4qVnG.png" alt="图1"></p>
<p>最终的$\boldsymbol H$的非零区域如下图左侧所示</p>
<p><img src="https://s2.loli.net/2021/12/19/ghLIYDanKlBc48C.png" alt="图2"></p>
<p>与非零块与图模型中的边一一对应。</p>
<p>有了这种性质就可以将线性方程组$\boldsymbol H\Delta\boldsymbol x=\boldsymbol g$分块进行求解（详见书）</p>
<h4><span id="鲁棒核函数">鲁棒核函数</span></h4>
<p>相比于滤波器的没有异常检测机制问题，非线性优化可以将误差项中的二范数换成鲁棒的核函数。</p>
<h2><span id="问题">问题</span></h2>
<p>没什么问题，只是这章东西太多了很多地方理解的还不够深入。</p>
<h2><span id="计划">计划</span></h2>
<p>跑一下后端BA的代码。</p>
<p>学习《视觉SLAM十四讲》第十章。</p>

</div> 

<script>
    window.onload = detectors();
</script>
    <div class="post-footer">
    <div class="h-line-primary"></div>
    <nav class="post-nav">
        <div class="prev-item">
           
                <div class="icon arrow-left"></div>
                <div class="post-link">
                    <a href="/2021/12/22/Install-CUDA/">Prev</a>
                </div>
            
        </div>
        <div class="next-item">
            
                <div class="icon arrow-right"></div>
                <div class="post-link">
                  <a href="/2021/12/18/A-bug-in-FIFA-22/">Next</a>  
                </div>  
            
        </div>
    </nav>
</div>

    
      <div class="post-comment">

    
        <div id="vcomments"></div>
        <script>
            var META = ['nick', 'mail', 'link'];
            var meta = 'nick,mail';
            meta = meta.split(',').filter(item => {
                return META.includes(item);
            });
            new Valine({
                el: '#vcomments',
                appId: 'cKgvUMr2Olh4nFGVLuAYT9qR-gzGzoHsz',
                appKey: 'O8oYV9aAIm2Sikg4CVAAi1W1',
                lang: 'en',
                placeholder: 'Say something',
                avatar: 'mp',
                meta: meta
            })
        </script>    
     

     
    
    

</div>
     
  
</article>
        </div>
      </div>
      
      <div class="footer">
    <div class="flex-container">
        <div class="footer-text">
            
            <!-- 
                Liwenjian |
             -->
            <br>jesse@keep-alive:~<a id="pathname"></a>$ <a id="btapp";></a>
            
                <br>Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/zoeingwingkei/frame/">Frame</a>
            
        </div>
    </div>
</div>

<script src="/js/typewriter.js"></script>
<script>
    var pathname = window.location.pathname;
    document.getElementById('pathname').innerText = pathname;
    const btapp = document.getElementById('btapp');

    const bttypewriter = new Typewriter(btapp, {
        loop: true
    });

    bttypewriter.typeString('mkdir /cool/code')
        .pauseFor(800)
        .deleteChars(4)
        .typeString('life')
        .pauseFor(800)
        .deleteAll()
        .typeString('have fun')
        .pauseFor(800)
        .start();
</script>

    </div>

  </body>
</html>
